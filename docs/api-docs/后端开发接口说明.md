# AngusAI 后端SpringBoot服务开发接口说明

## 项目结构概览

AngusAI后端服务采用分层架构设计，主要包含以下模块：

```
service/
├── api/          # API接口层 - 定义对外接口
├── core/         # 核心业务层 - 包含业务逻辑
├── boot/         # 启动模块 - 应用启动和配置
└── conf/         # 配置文件
```

## 核心模块详解

### 1. API模块 (`api/`)

- **作用**: 定义对外API接口和DTO
- **主要文件**:
    - `src/main/java/cloud/xcan/angus/` - 接口定义
    - `src/main/resources/i18n/` - 国际化资源文件

### 2. Core模块 (`core/`) - 核心业务层

采用DDD（领域驱动设计）分层架构，以Prompt模块为例展示完整的分层结构：

```
core/src/main/java/cloud/xcan/angus/core/ai/
│
├── interfaces/           # 接口层（Interface Layer）- 用户接口层
│   └── prompt/
│       ├── PromptRest.java                    # REST控制器 - HTTP接口入口
│       └── facade/                           # 门面层
│           ├── PromptFacade.java             # 门面接口 - 定义业务接口
│           ├── dto/                          # 数据传输对象（DTO）
│           │   ├── PromptCreateDto.java      # 创建请求DTO
│           │   ├── PromptUpdateDto.java      # 更新请求DTO
│           │   └── PromptFindDto.java       # 查询请求DTO（继承PageQuery）
│           ├── vo/                           # 视图对象（VO）
│           │   ├── PromptDetailVo.java       # 详情视图对象
│           │   ├── PromptListVo.java         # 列表视图对象
│           │   └── PromptStatsVo.java        # 统计视图对象
│           └── internal/                    # 内部实现（隐藏实现细节）
│               ├── PromptFacadeImpl.java     # 门面实现类
│               └── assembler/                # 组装器（DTO/Domain/VO转换）
│                   └── PromptAssembler.java  # 数据转换器
│
├── application/          # 应用层（Application Layer）- 应用服务层
│   ├── cmd/             # 命令服务（Command Service）- 写操作
│   │   └── prompt/
│   │       ├── PromptCmd.java                # 命令接口
│   │       └── impl/
│   │           └── PromptCmdImpl.java         # 命令实现（继承CommCmd）
│   ├── query/           # 查询服务（Query Service）- 读操作
│   │   └── prompt/
│   │       ├── PromptQuery.java              # 查询接口
│   │       └── impl/
│   │           └── PromptQueryImpl.java       # 查询实现
│   └── converter/      # 应用层转换器（业务对象组装）
│       └── PromptConverter.java              # 领域对象转换器
│
├── domain/              # 领域层（Domain Layer）- 核心业务层
│   └── prompt/
│       ├── Prompt.java                       # 领域实体（Entity）
│       ├── PromptCategory.java               # 领域实体
│       ├── PromptFavorites.java             # 领域实体
│       ├── PromptRepo.java                  # 仓储接口（Repository）
│       ├── PromptSearchRepo.java            # 搜索仓储接口
│       └── PromptCategoryRepo.java          # 仓储接口
│
└── infra/               # 基础设施层（Infrastructure Layer）- 技术实现层
    ├── persistence/     # 持久化实现
    │   ├── mysql/       # MySQL实现目录
    │   │   └── prompt/
    │   │       ├── PromptRepoMysql.java         # MySQL仓储实现
    │   │       ├── PromptCategoryRepoMysql.java # MySQL分类仓储实现
    │   │       └── PromptFavoritesRepoMysql.java # MySQL收藏仓储实现
    │   └── postgres/     # PostgreSQL实现目录
    │       └── prompt/
    │           ├── PromptRepoPostgres.java       # PostgreSQL仓储实现
    │           ├── PromptCategoryRepoPostgres.java # PostgreSQL分类仓储实现
    │           └── PromptFavoritesRepoPostgres.java # PostgreSQL收藏仓储实现
    ├── search/          # 搜索实现
    │   └── PromptSearchRepoMysql.java       # MySQL全文搜索实现
    ├── job/             # 定时任务
    ├── installation/    # 安装配置
    └── util/            # 工具类
```

#### DDD分层架构说明

**1. 接口层（Interfaces Layer）**
- **职责**: 处理用户请求，提供HTTP接口，参数验证，响应格式化
- **包含**: REST控制器、Facade门面、DTO/VO、Assembler
- **特点**: 
  - REST控制器只负责HTTP协议相关处理
  - Facade层协调应用服务，进行DTO/VO转换
  - 不包含业务逻辑

**2. 应用层（Application Layer）**
- **职责**: 协调领域对象完成业务用例，事务管理，业务流程编排
- **包含**: 
  - `cmd/`: 命令服务（写操作）- 创建、更新、删除等
  - `query/`: 查询服务（读操作）- 查询、统计等
  - `converter/`: 应用层数据转换器
- **特点**:
  - Cmd服务使用 `@Transactional` 管理事务
  - Query服务负责数据查询和关联数据填充
  - 使用 `BizTemplate` 进行参数校验和业务处理

**3. 领域层（Domain Layer）**
- **职责**: 核心业务逻辑，领域模型，业务规则
- **包含**: 
  - 领域实体（Entity）
  - 值对象（Value Object）
  - 仓储接口（Repository Interface）
  - 领域服务（Domain Service，如需要）
- **特点**:
  - 不依赖其他层，保持领域模型纯净
  - 定义仓储接口，不包含实现
  - 包含业务规则和领域逻辑

**4. 基础设施层（Infrastructure Layer）**
- **职责**: 技术实现，为其他层提供技术支撑
- **包含**: 
  - **持久化实现** (`persistence/`):
    - `mysql/`: MySQL数据库实现目录
    - `postgres/`: PostgreSQL数据库实现目录
    - 每个数据库目录下按业务模块组织（如 `prompt/`, `chat/` 等）
  - **搜索实现** (`search/`): 全文搜索实现（目前主要为MySQL实现）
  - **定时任务** (`job/`): 定时任务实现
  - **安装配置** (`installation/`): 安装相关配置
  - **工具类** (`util/`): 通用工具类
- **特点**:
  - 实现领域层定义的接口（如 `PromptRepo`）
  - MySQL和PostgreSQL实现在不同目录，便于维护和切换
  - 依赖领域层，不依赖应用层和接口层
  - 可替换的技术实现（通过配置选择MySQL或PostgreSQL）
  - 使用 `@Repository` 注解标记为Spring组件

#### 数据流向和依赖关系

```
HTTP请求
    ↓
[REST层] PromptRest
    ↓ (调用)
[Facade层] PromptFacade → PromptFacadeImpl
    ↓ (DTO → Domain转换) ↓ (调用)
[应用层] PromptCmd/PromptQuery
    ↓ (Domain对象) ↓ (调用)
[领域层] Prompt实体 + PromptRepo接口
    ↓ (实现，根据配置选择)
[基础设施层] 
    ├── persistence/mysql/prompt/PromptRepoMysql
    ├── persistence/postgres/prompt/PromptRepoPostgres
    └── search/PromptSearchRepoMysql
    ↓
数据库/搜索引擎（MySQL或PostgreSQL）
```

**依赖规则**:
- ✅ 接口层 → 应用层 → 领域层 ← 基础设施层
- ✅ 上层可以依赖下层，下层不能依赖上层
- ✅ 领域层不依赖任何其他层（保持纯净）
- ✅ 基础设施层实现领域层定义的接口

### 3. Boot模块 (`boot/`) - 启动模块

- **主启动类**: `XCanAngusAIApplication.java`
- **配置文件**: `application.yml`
- **依赖管理**: 集成各种starter组件

## 核心类示例

### 1. REST控制器示例（完整版）

REST控制器是接口层的入口，负责接收HTTP请求并返回响应。

**关键要点：**
- 使用 `@RestController` 和 `@RequestMapping` 定义控制器
- 使用 `@Tag` 定义API分组，`@Operation` 定义操作描述
- 使用 `@ApiResponses` 定义响应状态码说明
- 使用 `@Valid` 和 `@ParameterObject` 进行参数验证
- 返回类型统一使用 `ApiLocaleResult<T>` 包装
- 使用 `@ResponseStatus` 指定HTTP状态码

```java
@Tag(name = "Prompt", description = "提示词管理 - 提示词的创建、管理、搜索、收藏等功能")
@Validated
@RestController
@RequestMapping("/api/v1/prompts")
public class PromptRest {

  @Resource
  private PromptFacade promptFacade;

  // 创建资源 - POST
  @Operation(operationId = "createPrompt", summary = "创建提示词", description = "创建新提示词")
  @ApiResponses(value = {
      @ApiResponse(responseCode = "201", description = "提示词创建成功")
  })
  @ResponseStatus(HttpStatus.CREATED)
  @PostMapping
  public ApiLocaleResult<PromptDetailVo> create(
      @Valid @RequestBody PromptCreateDto dto) {
    PromptDetailVo result = promptFacade.create(dto);
    return ApiLocaleResult.success(result);
  }

  // 更新资源 - PATCH
  @Operation(operationId = "updatePrompt", summary = "更新提示词", description = "更新提示词基本信息")
  @ApiResponses(value = {
      @ApiResponse(responseCode = "200", description = "更新成功")
  })
  @ResponseStatus(HttpStatus.OK)
  @PatchMapping("/{id}")
  public ApiLocaleResult<PromptDetailVo> update(
      @Parameter(description = "提示词ID") @PathVariable Long id,
      @Valid @RequestBody PromptUpdateDto dto) {
    return ApiLocaleResult.success(promptFacade.update(id, dto));
  }

  // 删除资源 - DELETE
  @Operation(operationId = "deletePrompt", summary = "删除提示词", description = "删除指定提示词")
  @ApiResponses(value = {
      @ApiResponse(responseCode = "204", description = "删除成功")
  })
  @ResponseStatus(HttpStatus.NO_CONTENT)
  @DeleteMapping("/{id}")
  public void delete(
      @Parameter(description = "提示词ID") @PathVariable Long id) {
    promptFacade.delete(id);
  }

  // 查询单个资源 - GET
  @Operation(operationId = "getPromptDetail", summary = "获取提示词详情", description = "获取指定提示词的详细信息")
  @ApiResponses(value = {
      @ApiResponse(responseCode = "200", description = "提示词详情获取成功"),
      @ApiResponse(responseCode = "404", description = "提示词不存在")
  })
  @ResponseStatus(HttpStatus.OK)
  @GetMapping("/{id}")
  public ApiLocaleResult<PromptDetailVo> getDetail(
      @Parameter(description = "提示词ID") @PathVariable Long id) {
    return ApiLocaleResult.success(promptFacade.getDetail(id));
  }

  // 查询列表 - GET（支持分页和搜索）
  @Operation(operationId = "getPromptList", summary = "获取提示词列表", description = "获取当前用户的提示词列表，支持分页、搜索和筛选")
  @ApiResponses(value = {
      @ApiResponse(responseCode = "200", description = "提示词列表获取成功")
  })
  @ResponseStatus(HttpStatus.OK)
  @GetMapping
  public ApiLocaleResult<PageResult<PromptListVo>> list(
      @Valid @ParameterObject PromptFindDto dto) {
    return ApiLocaleResult.success(promptFacade.list(dto));
  }

  // 业务操作 - POST（非CRUD操作）
  @Operation(operationId = "toggleFavoritePrompt", summary = "收藏/取消收藏", description = "收藏或取消收藏提示词")
  @PostMapping("/{id}/favorite")
  public ApiLocaleResult<PromptDetailVo> toggleFavorite(
      @Parameter(description = "提示词ID") @PathVariable Long id,
      @Parameter(description = "是否收藏") @RequestParam Boolean isFavorite) {
    return ApiLocaleResult.success(promptFacade.toggleFavorite(id, isFavorite));
  }
}
```

### 2. 领域实体示例

领域实体是业务的核心，代表业务概念和业务规则。

**关键要点：**
- 继承 `TenantAuditingEntity<Entity, Long>`（多租户+审计）或 `TenantEntity<Entity, Long>`（仅多租户）
- 实现 `identity()` 方法返回主键
- 使用 `@Transient` 标记非持久化字段（如关联数据、计算字段）
- 使用 `@Type(JsonType.class)` 处理JSON类型字段
- 重写 `equals()` 和 `hashCode()` 方法

```java
@Setter
@Getter
@Entity
@Table(name = "ai_prompt")
public class Prompt extends TenantAuditingEntity<Prompt, Long> {

  @Id
  private Long id;

  @Column(name = "title", nullable = false, length = 100)
  private String title;

  @Column(name = "content", nullable = false, columnDefinition = "TEXT")
  private String content;

  @Column(name = "category_id", nullable = false)
  private Long categoryId;

  @Type(JsonType.class)
  @Column(name = "tags", columnDefinition = "json")
  private List<String> tags;

  @Column(name = "usage_count", nullable = false)
  private Long usageCount = 0L;

  // 非持久化字段 - 用于临时存储关联数据
  @Transient
  private Boolean isFavorite;
  
  @Transient
  private Boolean isSystem;
  
  @Transient
  private Long favorites;

  @Override
  public Long identity() {
    return id;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Prompt prompt)) return false;
    return Objects.equals(id, prompt.id)
        && Objects.equals(title, prompt.title)
        && Objects.equals(content, prompt.content);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, title, content);
  }
}
```

### 3. 仓储接口示例

仓储接口定义数据访问方法，支持标准JPA方法和自定义查询。

**关键要点：**
- 继承 `BaseRepository<Entity, Long>` 获得基础CRUD能力
- 使用 `@NoRepositoryBean` 标记基础仓储接口
- 方法命名遵循Spring Data JPA规范（如 `findByXxx`, `existsByXxx`）
- 使用 `@Query` 编写自定义查询（JPQL或原生SQL）
- 对于全文搜索，创建 `EntitySearchRepo` 继承 `CustomBaseRepository<Entity>`

```java
// 基础仓储接口
@NoRepositoryBean
public interface PromptRepo extends BaseRepository<Prompt, Long> {

  // 标准查询方法（Spring Data JPA自动实现）
  long countByCreatedBy(Long createdBy);
  long countByCategoryId(Long categoryId);
  boolean existsByTitle(String title);
  boolean existsByTitleAndIdNot(String title, Long id);

  // 自定义查询 - JPQL
  @Query("select p.categoryId, count(p) from Prompt p where p.categoryId in :ids group by p.categoryId")
  List<Object[]> countByCategoryIds(@Param("ids") List<Long> ids);
}

// 搜索仓储接口（用于全文搜索）
@NoRepositoryBean
public interface PromptSearchRepo extends CustomBaseRepository<Prompt> {
  // 继承全文搜索能力
}
```

### 4. 门面服务示例（Facade层）

门面服务是接口层和应用层之间的桥梁，负责协调应用服务并组装返回结果。

**关键要点：**
- 门面接口定义业务方法，返回VO对象
- 实现类使用 `@Service` 注解
- 注入 `Cmd`（命令服务）和 `Query`（查询服务）
- 使用 `Assembler` 进行DTO/Domain/VO转换
- 使用 `buildVoPageResult()` 构建分页结果
- 使用 `getMatchSearchFields()` 获取全文搜索字段

```java
// 门面接口
public interface PromptFacade {

  /**
   * 创建提示词
   */
  PromptDetailVo create(PromptCreateDto dto);

  /**
   * 更新提示词
   */
  PromptDetailVo update(Long id, PromptUpdateDto dto);

  /**
   * 删除提示词
   */
  void delete(Long id);

  /**
   * 获取提示词详情
   */
  PromptDetailVo getDetail(Long id);

  /**
   * 获取提示词列表
   */
  PageResult<PromptListVo> list(PromptFindDto dto);
}

// 门面实现类
@Service
public class PromptFacadeImpl implements PromptFacade {

  @Resource
  private PromptCmd promptCmd;      // 命令服务（写操作）

  @Resource
  private PromptQuery promptQuery;  // 查询服务（读操作）

  @Override
  public PromptDetailVo create(PromptCreateDto dto) {
    // DTO -> Domain
    Prompt prompt = PromptAssembler.toCreateDomain(dto);
    // 调用命令服务保存
    Prompt saved = promptCmd.create(prompt);
    // Domain -> VO
    return PromptAssembler.toDetailVo(saved);
  }

  @Override
  public PromptDetailVo update(Long id, PromptUpdateDto dto) {
    Prompt prompt = PromptAssembler.toUpdateDomain(id, dto);
    Prompt saved = promptCmd.update(prompt);
    return PromptAssembler.toDetailVo(saved);
  }

  @Override
  public void delete(Long id) {
    promptCmd.delete(id);
  }

  @Override
  public PromptDetailVo getDetail(Long id) {
    Prompt prompt = promptQuery.findAndCheck(id);
    return PromptAssembler.toDetailVo(prompt);
  }

  @Override
  public PageResult<PromptListVo> list(PromptFindDto dto) {
    // DTO -> Specification（查询条件）
    GenericSpecification<Prompt> spec = PromptAssembler.getSpecification(dto);
    // 查询数据
    Page<Prompt> page = promptQuery.find(spec, dto.tranPage(),
        dto.fullTextSearch, getMatchSearchFields(dto.getClass()));
    // Domain -> VO（分页结果）
    return buildVoPageResult(page, PromptAssembler::toListVo);
  }
}
```

### 5. 应用层服务示例

应用层分为命令服务（Cmd）和查询服务（Query），分别处理写操作和读操作。

#### 5.1 命令服务（Cmd）- 写操作

**关键要点：**
- 命令接口定义写操作方法，参数和返回值使用Domain对象
- 实现类继承 `CommCmd<Entity, Long>` 获得基础CRUD能力
- 使用 `@Service` 注解
- 使用 `BizTemplate` 进行业务处理（参数校验 + 业务逻辑）
- 使用 `@Transactional` 保证事务性
- 重写 `getRepository()` 方法返回仓储

```java
// 命令接口
public interface PromptCmd {

  /**
   * 创建提示词
   */
  Prompt create(Prompt prompt);

  /**
   * 更新提示词
   */
  Prompt update(Prompt prompt);

  /**
   * 删除提示词
   */
  void delete(Long id);
}

// 命令实现类
@Service
public class PromptCmdImpl extends CommCmd<Prompt, Long> implements PromptCmd {

  @Resource
  private PromptRepo promptRepo;

  @Resource
  private PromptQuery promptQuery;

  @Override
  @Transactional
  public Prompt create(Prompt prompt) {
    return new BizTemplate<Prompt>() {
      @Override
      protected void checkParams() {
        // 参数校验
        if (promptQuery.existsByTitle(prompt.getTitle())) {
          throw ResourceExisted.of("提示词标题「{0}」已存在", new Object[]{prompt.getTitle()});
        }
      }

      @Override
      protected Prompt process() {
        // 业务逻辑处理
        insert(prompt);  // 继承自CommCmd的方法
        return prompt;
      }
    }.execute();
  }

  @Override
  @Transactional
  public Prompt update(Prompt prompt) {
    return new BizTemplate<Prompt>() {
      Prompt promptDb;

      @Override
      protected void checkParams() {
        // 获取并校验
        promptDb = promptQuery.findAndCheck(prompt.getId());
      }

      @Override
      protected Prompt process() {
        // 更新操作
        update(prompt, promptDb);  // 继承自CommCmd的方法
        return promptDb;
      }
    }.execute();
  }

  @Override
  @Transactional
  public void delete(Long id) {
    new BizTemplate<Void>() {
      @Override
      protected void checkParams() {
        promptQuery.findAndCheck(id);  // 校验存在性
      }

      @Override
      protected Void process() {
        promptRepo.deleteById(id);
        return null;
      }
    }.execute();
  }

  @Override
  protected BaseRepository<Prompt, Long> getRepository() {
    return promptRepo;
  }
}
```

#### 5.2 查询服务（Query）- 读操作

**关键要点：**
- 查询接口定义读操作方法
- 实现类使用 `@Service` 注解
- 使用 `BizTemplate` 进行业务处理
- 支持全文搜索和标准查询两种模式
- 查询后可以设置关联数据（如用户信息、统计信息等）

```java
// 查询接口
public interface PromptQuery {

  /**
   * 根据ID查询提示词（带校验）
   */
  Prompt findAndCheck(Long id);

  /**
   * 查询提示词列表（支持全文搜索）
   */
  Page<Prompt> find(GenericSpecification<Prompt> spec, PageRequest pageable,
      boolean fullTextSearch, String[] match);

  /**
   * 检查标题是否存在
   */
  boolean existsByTitle(String title);
}

// 查询实现类
@Service
public class PromptQueryImpl implements PromptQuery {

  @Resource
  private PromptRepo promptRepo;

  @Resource
  private PromptSearchRepo promptSearchRepo;

  @Override
  public Prompt findAndCheck(Long id) {
    return new BizTemplate<Prompt>() {
      @Override
      protected Prompt process() {
        Prompt prompt = promptRepo.findById(id)
            .orElseThrow(() -> ResourceNotFound.of("提示词未找到", new Object[]{}));
        
        // 设置关联数据
        setIsSystemFlag(List.of(prompt));
        setFavoritesCount(List.of(prompt));
        setIsFavoriteFlag(List.of(prompt));
        
        return prompt;
      }
    }.execute();
  }

  @Override
  public Page<Prompt> find(GenericSpecification<Prompt> spec, PageRequest pageable,
      boolean fullTextSearch, String[] match) {
    return new BizTemplate<Page<Prompt>>() {
      @Override
      protected Page<Prompt> process() {
        // 根据是否全文搜索选择不同的仓储
        Page<Prompt> page = fullTextSearch
            ? promptSearchRepo.find(spec.getCriteria(), pageable, Prompt.class, match)
            : promptRepo.findAll(spec, pageable);

        // 批量设置关联数据
        if (page.hasContent()) {
          setIsSystemFlag(page.getContent());
          setFavoritesCount(page.getContent());
          setIsFavoriteFlag(page.getContent());
        }
        
        return page;
      }
    }.execute();
  }

  @Override
  public boolean existsByTitle(String title) {
    return promptRepo.existsByTitle(title);
  }
}
```

### 6. DTO和VO示例

#### 6.1 DTO（Data Transfer Object）- 请求参数

**关键要点：**
- 创建DTO继承 `PageQuery`（查询DTO）或直接定义（创建/更新DTO）
- 使用 `@Schema` 注解描述字段
- 使用Bean Validation注解进行参数校验（`@NotBlank`, `@NotNull`, `@Size`等）
- 查询DTO支持分页、排序、全文搜索等通用功能

```java
// 创建DTO
@Data
@Schema(description = "创建提示词请求参数")
public class PromptCreateDto {

  @NotBlank
  @Size(max = 100)
  @Schema(description = "提示词标题", requiredMode = RequiredMode.REQUIRED)
  private String title;

  @NotBlank
  @Size(max = 5000)
  @Schema(description = "提示词内容", requiredMode = RequiredMode.REQUIRED)
  private String content;

  @NotNull
  @Schema(description = "分类ID", requiredMode = RequiredMode.REQUIRED)
  private Long categoryId;

  @Schema(description = "标签")
  private List<String> tags;
}

// 查询DTO（继承PageQuery）
@Data
@EqualsAndHashCode(callSuper = true)
@Schema(description = "查询提示词请求参数")
public class PromptFindDto extends PageQuery {

  @Schema(description = "提示词标题")
  private String title;

  @Schema(description = "分类ID")
  private Long categoryId;

  @Schema(description = "是否收藏")
  private Boolean isFavorite;

  @Schema(description = "排序字段", allowableValues = {"id", "createdDate", "title"})
  private String orderBy = "createdDate";
}
```

#### 6.2 VO（View Object）- 响应对象

**关键要点：**
- 详情VO继承 `TenantAuditingVo`（包含审计字段）或直接定义
- 列表VO可以继承详情VO或单独定义（通常字段更少）
- 使用 `@Schema` 注解描述字段
- 使用 `@NameJoinField` 自动填充关联名称（如分类名称）

```java
// 详情VO，TenantAuditingVo类包含了审计字段
@EqualsAndHashCode(callSuper = true)
@Data
@Schema(description = "提示词详情")
public class PromptDetailVo extends TenantAuditingVo {

  @Schema(description = "ID")
  private Long id;

  @Schema(description = "标题")
  private String title;

  @Schema(description = "内容")
  private String content;

  @Schema(description = "分类ID")
  private Long categoryId;

  @Schema(description = "分类名称")
  @NameJoinField(id = "categoryId", repository = "promptCategoryRepo")
  private String categoryName;

  @Schema(description = "标签")
  private List<String> tags;

  @Schema(description = "是否收藏")
  private Boolean isFavorite;

  @Schema(description = "统计信息")
  private PromptStatsVo stats;
}

// 列表VO（字段通常更少）
@Data
@Schema(description = "提示词列表项")
public class PromptListVo extends PromptDetailVo {
  // 可以继承详情VO，或单独定义更少的字段
}
```

### 7. Assembler（组装器）示例

Assembler负责DTO、Domain、VO之间的转换，以及查询条件的构建。

**关键要点：**
- 静态工具类，提供静态方法进行转换
- `toCreateDomain()`: DTO -> Domain（创建）
- `toUpdateDomain()`: DTO -> Domain（更新）
- `toDetailVo()`: Domain -> 详情VO
- `toListVo()`: Domain -> 列表VO
- `getSpecification()`: DTO -> 查询条件（GenericSpecification）

```java
public class PromptAssembler {

  // DTO -> Domain（创建）
  public static Prompt toCreateDomain(PromptCreateDto dto) {
    Prompt prompt = new Prompt();
    prompt.setTitle(dto.getTitle());
    prompt.setContent(dto.getContent());
    prompt.setCategoryId(dto.getCategoryId());
    prompt.setTags(dto.getTags());
    prompt.setUsageCount(0L);
    return prompt;
  }

  // DTO -> Domain（更新）
  public static Prompt toUpdateDomain(Long id, PromptUpdateDto dto) {
    Prompt prompt = new Prompt();
    prompt.setId(id);
    prompt.setTitle(dto.getTitle());
    prompt.setContent(dto.getContent());
    prompt.setCategoryId(dto.getCategoryId());
    prompt.setTags(dto.getTags());
    return prompt;
  }

  // Domain -> 详情VO
  public static PromptDetailVo toDetailVo(Prompt prompt) {
    PromptDetailVo vo = new PromptDetailVo();
    vo.setId(prompt.getId());
    vo.setTitle(prompt.getTitle());
    vo.setContent(prompt.getContent());
    vo.setCategoryId(prompt.getCategoryId());
    vo.setTags(prompt.getTags());
    
    // 设置关联状态
    vo.setIsFavorite(prompt.getIsFavorite());
    vo.setIsSystem(nullSafe(prompt.getIsSystem(), false));
    
    // 设置统计信息
    PromptStatsVo statsVo = new PromptStatsVo();
    statsVo.setFavorites(nullSafe(prompt.getFavorites(), 0L));
    statsVo.setTotalUses(nullSafe(prompt.getUsageCount(), 0L));
    vo.setStats(statsVo);
    
    // 设置审计信息（继承自TenantAuditingVo）
    vo.setTenantId(prompt.getTenantId());
    vo.setCreatedBy(prompt.getCreatedBy());
    vo.setCreatedDate(prompt.getCreatedDate());
    vo.setModifiedBy(prompt.getModifiedBy());
    vo.setModifiedDate(prompt.getModifiedDate());
    
    return vo;
  }

  // Domain -> 列表VO
  public static PromptListVo toListVo(Prompt prompt) {
    PromptListVo vo = new PromptListVo();
    // ... 类似toDetailVo，但字段可能更少
    return vo;
  }

  // DTO -> 查询条件
  public static GenericSpecification<Prompt> getSpecification(PromptFindDto dto) {
    Set<SearchCriteria> filters = new SearchCriteriaBuilder<>(dto)
        .rangeSearchFields("id", "createdDate", "modifiedDate")  // 范围查询字段
        .orderByFields("id", "createdDate", "modifiedDate", "title")  // 排序字段
        .matchSearchFields("title", "content")  // 全文搜索字段
        .build();
    return new GenericSpecification<>(filters);
  }
}
```

## 快速开发接口指南

### 1. 创建新接口的完整步骤

#### 步骤1: 创建领域实体 (`domain/xxx/`)

```java
@Setter
@Getter
@Entity
@Table(name = "your_table")
public class YourEntity extends TenantAuditingEntity<YourEntity, Long> {
  @Id
  private Long id;
  // ... 字段定义
  @Override
  public Long identity() { return id; }
}
```

#### 步骤2: 创建仓储接口 (`domain/xxx/`)

```java
@NoRepositoryBean
public interface YourRepo extends BaseRepository<YourEntity, Long> {
  // 自定义查询方法
}

// 如需全文搜索
@NoRepositoryBean
public interface YourSearchRepo extends CustomBaseRepository<YourEntity> {
}
```

#### 步骤2.1: 创建持久化实现 (`infra/persistence/mysql/xxx/` 和 `postgres/xxx/`)

```java
// MySQL实现
@Repository
public interface YourRepoMysql extends YourRepo {
  // 继承领域层接口，Spring会根据配置自动选择实现
}

// PostgreSQL实现
@Repository
public interface YourRepoPostgres extends YourRepo {
  // 继承领域层接口，Spring会根据配置自动选择实现
}

// 如需全文搜索（通常在search目录下）
@Repository
public class YourSearchRepoMysql extends SimpleSearchRepository<YourEntity>
    implements YourSearchRepo {
  // 实现全文搜索功能
}
```

#### 步骤3: 创建DTO和VO (`interfaces/xxx/facade/dto/` 和 `vo/`)

```java
// 创建DTO
@Data
@Schema(description = "创建XXX请求参数")
public class YourCreateDto {
  @NotBlank
  @Schema(description = "名称")
  private String name;
}

// 查询DTO
@Data
@EqualsAndHashCode(callSuper = true)
@Schema(description = "查询XXX请求参数")
public class YourFindDto extends PageQuery {
  @Schema(description = "名称")
  private String name;
}

// 详情VO
@Data
@EqualsAndHashCode(callSuper = true)
@Schema(description = "XXX详情")
public class YourDetailVo extends TenantAuditingVo {
  @Schema(description = "ID")
  private Long id;
  // ...
}
```

#### 步骤4: 创建Assembler (`interfaces/xxx/facade/internal/assembler/`)

```java
public class YourAssembler {
  public static YourEntity toCreateDomain(YourCreateDto dto) { /* ... */ }
  public static YourDetailVo toDetailVo(YourEntity entity) { /* ... */ }
  public static GenericSpecification<YourEntity> getSpecification(YourFindDto dto) { /* ... */ }
}
```

#### 步骤5: 创建应用层服务 (`application/cmd/xxx/` 和 `query/xxx/`)

```java
// 命令接口
public interface YourCmd {
  YourEntity create(YourEntity entity);
  void delete(Long id);
}

// 命令实现
@Service
public class YourCmdImpl extends CommCmd<YourEntity, Long> implements YourCmd {
  // ...
}

// 查询接口
public interface YourQuery {
  YourEntity findAndCheck(Long id);
  Page<YourEntity> find(GenericSpecification<YourEntity> spec, PageRequest pageable, 
      boolean fullTextSearch, String[] match);
}

// 查询实现
@Service
public class YourQueryImpl implements YourQuery {
  // ...
}
```

#### 步骤6: 创建门面服务 (`interfaces/xxx/facade/`)

```java
// 门面接口
public interface YourFacade {
  YourDetailVo create(YourCreateDto dto);
  PageResult<YourListVo> list(YourFindDto dto);
}

// 门面实现
@Service
public class YourFacadeImpl implements YourFacade {
  @Resource
  private YourCmd yourCmd;
  @Resource
  private YourQuery yourQuery;
  // ...
}
```

#### 步骤7: 创建REST控制器 (`interfaces/xxx/`)

```java
@Tag(name = "Your", description = "XXX管理")
@Validated
@RestController
@RequestMapping("/api/v1/yours")
public class YourRest {
  @Resource
  private YourFacade yourFacade;
  
  @PostMapping
  public ApiLocaleResult<YourDetailVo> create(@Valid @RequestBody YourCreateDto dto) {
    return ApiLocaleResult.success(yourFacade.create(dto));
  }
  // ...
}
```

### 2. 常用注解说明

#### 2.1 JPA相关注解

- `@Entity`: JPA实体类
- `@Table`: 指定数据库表名
- `@Id`: 主键字段
- `@Column`: 字段映射（可指定列名、长度、是否可空等）
- `@Enumerated`: 枚举类型映射（`EnumType.STRING` 或 `EnumType.ORDINAL`）
- `@Transient`: 非持久化字段（临时字段）
- `@Type(JsonType.class)`: JSON类型字段（使用Hypersistence Utils）
- `@EntityListeners`: 实体监听器（如 `TenantListener`）

#### 2.2 Spring Data JPA注解

- `@NoRepositoryBean`: 标记基础仓储接口
- `@Query`: 自定义查询（JPQL或原生SQL）
- `@Param`: 查询参数绑定

#### 2.3 Swagger/OpenAPI注解

- `@Tag`: API分组（用于控制器类）
- `@Operation`: API操作描述（用于方法）
- `@ApiResponses`: 响应状态码说明
- `@ApiResponse`: 单个响应说明
- `@Parameter`: 参数描述
- `@Schema`: 字段描述（用于DTO/VO）

#### 2.4 Bean Validation注解

- `@Valid`: 启用参数验证
- `@Validated`: 类级别验证
- `@NotBlank`: 字符串非空且非空白
- `@NotNull`: 非空
- `@Size`: 长度限制
- `@Min`/`@Max`: 数值范围

#### 2.5 Spring MVC注解

- `@RestController`: REST控制器
- `@RequestMapping`: 请求映射
- `@GetMapping`/`@PostMapping`/`@PatchMapping`/`@DeleteMapping`: HTTP方法映射
- `@PathVariable`: 路径变量
- `@RequestParam`: 请求参数
- `@RequestBody`: 请求体
- `@ParameterObject`: 对象参数（用于查询参数）
- `@ResponseStatus`: HTTP状态码

#### 2.6 依赖注入注解

- `@Resource`: JSR-250标准注入（推荐）
- `@Autowired`: Spring注入
- `@Service`: 服务层组件
- `@Component`: 通用组件

#### 2.7 事务注解

- `@Transactional`: 事务管理（通常用于Cmd层）

### 3. 配置说明

- **数据库**: 支持MySQL和PostgreSQL
- **缓存**: 集成Redis和Caffeine二级缓存
- **搜索**: 支持全文搜索
- **国际化**: 多语言支持
- **日志**: 集成Logback
- **API文档**: 自动生成Swagger文档

### 4. 开发最佳实践

#### 4.1 DDD分层架构原则

1. **严格分层**: 
   - **接口层（Interfaces）**: 只负责HTTP请求/响应、参数验证、Swagger文档
   - **应用层（Application）**: 协调领域对象完成业务用例、事务管理、业务流程编排
   - **领域层（Domain）**: 核心业务逻辑、领域模型、业务规则（不依赖其他层）
   - **基础设施层（Infrastructure）**: 技术实现、持久化、搜索等（实现领域层接口）

2. **依赖方向（依赖倒置原则）**: 
   ```
   接口层（Interfaces）
      ↓ 依赖
   应用层（Application）
      ↓ 依赖
   领域层（Domain）← 基础设施层（Infrastructure）
   ```
   - 上层依赖下层，下层不依赖上层
   - 领域层不依赖任何其他层（保持纯净）
   - 基础设施层实现领域层定义的接口（依赖倒置）

3. **职责划分**:
   - **接口层**:
     - REST控制器：HTTP协议处理、参数验证、响应格式化
     - Facade门面：协调应用服务、DTO/VO转换、结果组装
     - Assembler：DTO ↔ Domain ↔ VO 转换
   - **应用层**:
     - Cmd服务：写操作（create/update/delete）、业务校验、事务管理（@Transactional）
     - Query服务：读操作（find/list）、数据查询、关联数据填充、全文搜索
   - **领域层**:
     - 领域实体：业务对象、业务规则、领域逻辑
     - 仓储接口：定义数据访问契约（不包含实现）
   - **基础设施层**:
     - 仓储实现：实现领域层定义的仓储接口
     - 搜索实现：实现全文搜索功能
     - 工具类：提供技术支撑

4. **数据流转示例（以创建提示词为例）**:
   ```
   1. HTTP POST /api/v1/prompts
      ↓
   2. PromptRest.create(PromptCreateDto dto)
      ↓ 调用
   3. PromptFacade.create(dto)
      ↓ DTO → Domain转换
   4. PromptAssembler.toCreateDomain(dto) → Prompt实体
      ↓ 调用
   5. PromptCmd.create(Prompt prompt)
      ↓ 业务校验 + 事务管理
   6. BizTemplate.checkParams() + process()
      ↓ 调用
   7. PromptRepo.save(prompt)
      ↓ 实现（根据配置选择）
   8. persistence/mysql/prompt/PromptRepoMysql.save() 
      或 persistence/postgres/prompt/PromptRepoPostgres.save()
      ↓
   9. 数据库（MySQL或PostgreSQL）
      ↓ 返回
   10. Prompt实体 → PromptAssembler.toDetailVo() → PromptDetailVo
      ↓
   11. ApiLocaleResult.success(vo) → HTTP响应
   ```

#### 4.2 命名规范

1. **类命名**:
   - 实体: `Xxx` (如 `Prompt`)
   - 仓储: `XxxRepo`, `XxxSearchRepo`
   - DTO: `XxxCreateDto`, `XxxUpdateDto`, `XxxFindDto`
   - VO: `XxxDetailVo`, `XxxListVo`
   - 服务: `XxxFacade`, `XxxCmd`, `XxxQuery`
   - 控制器: `XxxRest`
   - 组装器: `XxxAssembler`

2. **方法命名**:
   - Cmd层: `create`, `update`, `delete`, `toggleXxx`
   - Query层: `find`, `findAndCheck`, `existsByXxx`, `setXxxFlag`
   - Facade层: 与Cmd/Query保持一致

#### 4.3 异常处理

1. **统一异常**: 使用框架提供的异常类
   - `ResourceNotFound.of()`: 资源不存在
   - `ResourceExisted.of()`: 资源已存在
   - `ProtocolException.of()`: 协议异常

2. **异常信息**: 使用国际化消息键，支持多语言

#### 4.4 数据验证

1. **参数验证**: 
   - DTO使用Bean Validation注解
   - REST方法使用 `@Valid` 或 `@Validated`
   - Cmd层使用 `BizTemplate.checkParams()` 进行业务校验

2. **数据转换**: 
   - 使用Assembler进行DTO/Domain/VO转换
   - 避免在REST层直接操作Domain对象

#### 4.5 事务管理

1. **事务边界**: 
   - Cmd层方法使用 `@Transactional`
   - Query层通常不需要事务（只读）

2. **事务传播**: 
   - 默认使用 `REQUIRED`（加入现有事务或创建新事务）

#### 4.6 查询优化

1. **分页查询**: 
   - 查询DTO继承 `PageQuery`
   - 使用 `PageRequest` 进行分页
   - 返回 `PageResult<T>` 包装分页结果

2. **全文搜索**: 
   - 创建 `XxxSearchRepo` 继承 `CustomBaseRepository`
   - 使用 `SearchCriteriaBuilder` 构建查询条件
   - 通过 `fullTextSearch` 参数控制是否启用全文搜索

3. **关联数据**: 
   - 使用 `@Transient` 字段存储关联数据
   - 在Query层批量设置关联数据（避免N+1问题）
   - 使用 `@NameJoinField` 自动填充关联名称

#### 4.7 API文档

1. **Swagger注解**: 
   - 控制器使用 `@Tag` 定义分组
   - 方法使用 `@Operation` 描述操作
   - DTO/VO字段使用 `@Schema` 描述

2. **HTTP状态码**: 
   - 创建: `201 CREATED`
   - 更新: `200 OK`
   - 删除: `204 NO_CONTENT`
   - 查询: `200 OK`
   - 错误: `400 BAD_REQUEST`, `404 NOT_FOUND` 等

#### 4.8 代码组织

1. **包结构**: 
   ```
   interfaces/xxx/
   ├── XxxRest.java
   └── facade/
       ├── XxxFacade.java
       ├── dto/
       ├── vo/
       └── internal/
           ├── XxxFacadeImpl.java
           └── assembler/
               └── XxxAssembler.java
   ```

2. **文件组织**: 
   - 一个功能模块一个包
   - 相关类放在同一包下
   - 使用内部包（`internal`）隐藏实现细节

### 5. 关键工具类和框架组件

#### 5.1 基础类

- `TenantAuditingEntity<Entity, Long>`: 多租户+审计实体基类
- `TenantEntity<Entity, Long>`: 多租户实体基类
- `BaseRepository<Entity, Long>`: 基础仓储接口
- `CustomBaseRepository<Entity>`: 全文搜索仓储接口
- `CommCmd<Entity, Long>`: 命令服务基类
- `BizTemplate<T>`: 业务模板（参数校验+业务逻辑）
- `PageQuery`: 分页查询基类
- `TenantAuditingVo`: 审计VO基类

#### 5.2 工具类

- `SearchCriteriaBuilder`: 查询条件构建器
- `GenericSpecification<T>`: 通用查询规范
- `buildVoPageResult()`: 构建分页VO结果
- `getMatchSearchFields()`: 获取全文搜索字段
- `nullSafe()`: 空值安全处理

#### 5.3 响应包装

- `ApiLocaleResult<T>`: 统一响应包装（支持国际化）
- `PageResult<T>`: 分页结果包装

### 6. 完整开发流程示例

以创建"提示词管理"模块为例：

1. **创建数据库表** → 编写SQL脚本
2. **创建领域实体** → `Prompt.java`
3. **创建仓储接口** → `PromptRepo.java`, `PromptSearchRepo.java`
4. **创建DTO/VO** → `PromptCreateDto.java`, `PromptFindDto.java`, `PromptDetailVo.java`
5. **创建Assembler** → `PromptAssembler.java`
6. **创建应用服务** → `PromptCmd.java`, `PromptQuery.java` 及其实现
7. **创建门面服务** → `PromptFacade.java`, `PromptFacadeImpl.java`
8. **创建REST控制器** → `PromptRest.java`
9. **编写单元测试** → 测试各层功能
10. **完善Swagger文档** → 补充API文档

### 7. 启动配置

- **端口**: 默认1530
- **上下文路径**: `/`
- **配置文件**: `application.yml`
- **日志配置**: `spring-logback.xml`
- **健康检查**: `/actuator/health`
- **Swagger UI**: `/swagger-ui.html` 或 `/doc.html`

### 8. 常见问题

#### Q1: 何时使用 `TenantAuditingEntity` vs `TenantEntity`?
A: 如果需要记录创建人、创建时间、修改人、修改时间，使用 `TenantAuditingEntity`；否则使用 `TenantEntity`。

#### Q2: 何时需要创建 `SearchRepo`?
A: 当需要支持全文搜索功能时，创建 `XxxSearchRepo` 继承 `CustomBaseRepository`，并在 `infra/search/` 目录下创建实现类。

#### Q6: MySQL和PostgreSQL实现如何组织?
A: 
- MySQL实现在 `infra/persistence/mysql/` 目录下
- PostgreSQL实现在 `infra/persistence/postgres/` 目录下
- 两个目录下的结构保持一致，按业务模块组织（如 `prompt/`, `chat/` 等）
- 都继承领域层定义的接口（如 `PromptRepo`）
- Spring会根据配置自动选择使用哪个实现

#### Q3: Cmd和Query如何选择?
A: 写操作（增删改）放在Cmd层，读操作（查询）放在Query层。

#### Q4: 如何处理关联数据?
A: 在Domain实体中使用 `@Transient` 字段，在Query层查询后批量设置，避免N+1问题。

#### Q5: 如何实现软删除?
A: 在实体中添加 `deleted` 字段，重写仓储的 `delete` 方法，或使用JPA的 `@SQLDelete` 注解。

---

## DDD分层架构总结

### 架构优势

1. **职责清晰**: 每层职责明确，符合单一职责原则
   - 接口层：用户交互
   - 应用层：业务流程编排
   - 领域层：核心业务逻辑
   - 基础设施层：技术实现

2. **依赖倒置**: 领域层不依赖其他层，保持业务逻辑纯净
   - 领域层定义接口（如Repository）
   - 基础设施层实现接口
   - 便于替换技术实现（如MySQL ↔ PostgreSQL）

3. **易于扩展**: 新增功能只需按照规范添加对应层的代码
   - 遵循统一的分层结构
   - 各层职责明确，互不干扰

4. **统一规范**: 统一的开发规范，降低学习成本
   - 命名规范统一
   - 代码结构统一
   - 开发流程统一

5. **测试友好**: 分层设计便于单元测试和集成测试
   - 可以Mock各层依赖
   - 可以单独测试各层逻辑

6. **代码复用**: 基础类提供通用能力，减少重复代码
   - `CommCmd` 提供通用CRUD能力
   - `BaseRepository` 提供基础数据访问能力
   - `BizTemplate` 提供统一业务处理模板

### 关键设计模式

1. **门面模式（Facade Pattern）**: Facade层封装应用服务的复杂性
2. **仓储模式（Repository Pattern）**: 抽象数据访问，领域层不直接依赖数据库
3. **CQRS模式（Command Query Responsibility Segregation）**: Cmd和Query分离，读写分离
4. **依赖倒置原则（DIP）**: 领域层定义接口，基础设施层实现接口
5. **模板方法模式（Template Method）**: `BizTemplate` 提供统一的业务处理流程

### 开发建议

1. **严格遵循分层**: 不要跨层调用，保持依赖方向正确
2. **领域层保持纯净**: 领域层不依赖框架、不依赖基础设施
3. **合理使用Assembler**: 所有DTO/Domain/VO转换都通过Assembler
4. **事务边界清晰**: 事务管理在Cmd层，Query层通常不需要事务
5. **异常处理统一**: 使用框架提供的统一异常类

遵循本规范可以快速开发出高质量、易维护、符合DDD设计原则的RESTful API接口。
